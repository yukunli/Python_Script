"""
File:  test_sdk.py
=================
Copyright (c) 2015 Freescale Semiconductor

Brief
+++++
**Main file for KSDK project creation automation test**

.. codeauthor:: Bill.Yuan <Bill.Yuan@nxp.com>

.. sectionauthor:: Bill.Yuan <Bill.Yuan@nxp.com>

.. versionadded:: 0.0.3

++++
.. 0.0.2 -- Support ER test for SDK 2.0 KEx packages
.. 0.0.3 -- Support RC1 test for SDK 2.0 KEx packages
+++

"""
import os
import sys
import inspect
import unittest
from Tkinter import *
from ttk import *

import platform
import re

if 'Windows' == platform.system():
    import _winreg

import shutil, stat
import time

#add the src
cmd_folder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(\
                inspect.getfile( inspect.currentframe()))[0], os.pardir, "src")))
if cmd_folder not in sys.path:
    sys.path.insert(0, cmd_folder)

from ksdkTools import KsdkTools as kT
from ksdkGUI import PgGui, PGKSDK_VERSION, PGKSDK_NAME
import ksdkGUI as kGUI
import ksdkImg as kImg
import ksdkObj as kSdk
import json
from ksdkObj import ToolchainType
import xml.etree.ElementTree as ET

DEBUG = False
DEBUG_SLOW = False
# QUICK_TEST is used to only test one board/device/demo(for clone)
# If set it as "False", it will loop all combination and will take long time,
# you'd better prepare your disk space.
QUICK_TEST = False

# AUTO_VERIFICATION is used to auto check the projects that generated by this tool,
# check whether the CPU type is correct
AUTO_VERIFICATION = True

# Since some of device or board list will block the following test,
# this is a skip list we have to ignore temporally until the issues are fixed.
SKIP_LIST = ('')

# if using ASSERT, the case will stop immediately once assert failed.
# Disable ASSERT will continue test the loop even if there is assert failure
ASSERT = False

FAILURE_LOG_FILE = "_failure.log"
g_failure_count = 0

# timeout for each project creating
TIME_OUT = 15 # seconds

# some platforms do not support the RTOS, skip generate them
RTOS_NOT_AVAIBLE_LIST = ('FRDM-KL02Z', 'FRDM-KL03Z', 'FRDM-KV10Z', 'TWR-KM34Z75M', 'TWR-KV10Z32')

# global define
PROJECT_PRE = 'p_'

SDK1x_PRE = 'S1x_'
SDK2x_PRE = 'S2x_'

TEMP_QUICK_FOLDER = 'user_apps'
TEMP_ADVANCE_FOLDER = 'user_projects'

dict_board_folder = {}
dict_board_cpu = {}
dict_device_cpu = {}
evaluation_board_name = None

dict_os_lib = {'lib_rtos_none'      : 'ksdk_platform_lib',
               'lib_rtos_mqx'       : 'ksdk_mqx_lib',
               'lib_rtos_freertos'  : 'ksdk_freertos_lib',
               'lib_rtos_ucosii'    : 'ksdk_ucosii_lib',
               'lib_rtos_ucosiii'   : 'ksdk_ucosiii_lib' }

# clean the test environment, remove all generated projects
def get_quick_folder_root():
    quick_folder_root = 'examples'
    global sdk_info
    if sdk_info.isNewVersion():
        quick_folder_root = 'boards'

    return quick_folder_root

def remove_readonly(func, path, excinfo):
    #removes readonly tag from files/folders so they can be deleted
    excvalue = excinfo[1]
    if func in (os.rmdir, os.remove) and excvalue.errno == errno.EACCES:
        os.chmod(path, stat.S_IRWXU| stat.S_IRWXG| stat.S_IRWXO) # 0777
        func(path)
    else:
        raise


def clean_env():
    if DEBUG: print 'clean the test environment, remove all generated projects'
    global SDK_PATH
    global sdk_info

    temp_quick_root = os.path.join(SDK_PATH, get_quick_folder_root())
    if os.path.isdir(temp_quick_root):
        for item_level1 in os.listdir(temp_quick_root):
            for item_level2 in os.listdir(os.path.join(temp_quick_root, item_level1)):
                if re.match(TEMP_QUICK_FOLDER, item_level2):
                    print 'cleaning folder ' + os.path.join(os.path.join(temp_quick_root, \
                                                            item_level1), item_level2)
                    shutil.rmtree(os.path.join(os.path.join(temp_quick_root, item_level1), item_level2), onerror=remove_readonly)

    if not sdk_info.isNewVersion():
        temp_advance_folder = os.path.join(SDK_PATH, TEMP_ADVANCE_FOLDER)
        if os.path.isdir(temp_advance_folder):
            print 'cleaning folder ' + temp_advance_folder
            shutil.rmtree(temp_advance_folder, onerror=remove_readonly)


def load_manifest():
    global SDK_PATH

    tree = ET.parse(SDK_PATH + '/ksdk_manifest.xml')
    root = tree.getroot()
    for boards in root.findall('boards'):
        for board in boards:
            board_display_name = board.get('user_name')
            board_folder_name = board.get('name')
            dict_board_folder[board_display_name] = board_folder_name

    for boards in root.findall('boards'):
        for board in boards:
            board_display_name = board.get('user_name')
            default_cpu_name = board.get('package')
            dict_board_cpu[board_display_name] = default_cpu_name

    for devices in root.findall('devices'):
        for device in devices:
            device_name = device.get('full_name')
            if dict_device_cpu.get(device_name, None) == None:
                dict_device_cpu[device_name] = {}

            for dev_package in device.findall('package'):
                dev_package_name = dev_package.get('name')
                dict_device_cpu[device_name][dev_package_name] = dev_package_name # get all part number list

            for evaluation_boards in device.findall('evaluation_boards'):
                for evaluation_board in evaluation_boards:
                    global evaluation_board_name
                    evaluation_board_name = evaluation_board.get('name')
                    break #just get first board_name
                break
    if DEBUG:
        print 'load_manifest: '
        print dict_board_cpu
        print dict_device_cpu


class TestChooseBoard(unittest.TestCase):
    def setUp(self):
        """ Main file for KSDK Project Generator

        .. todo::

            test on Linux, OSX

        .. todo::

            go over comments for documentation; params, etc...

        """

        osName = platform.system()
        root = Tk()                                                # Call Tkinter object 'root'
        s = Style()

        #tkMessageBox.showinfo("Error", 'Path: ' + os.getcwd())

        # Set ttk style for the OS
        if osName == 'Linux':
            themeName = 'alt'
        elif osName == 'Windows':
            themeName = 'vista'
        elif osName == 'Darwin':
            themeName = 'aqua'

        themeNames = s.theme_names()
        if themeNames.count(themeName) == 1:
            s.theme_use(themeName)
        elif len(themeNames) > 0:
            s.theme_use(themeNames[0])

        if osName == 'Windows':                                     # Check if running on Windows
            try:
                root.iconbitmap(default='./kds_icon.ico')           # Use the .ico file if in Windows
            except TclError:
                root.iconbitmap(default=None)
        elif osName == 'Linux':
            img = Image("photo", data=kImg.boardImages['kds_icon.gif']) # Use the .gif file if in Linux
            root.tk.call('wm', 'iconphoto', root._w, img)

        root.title(PGKSDK_NAME + ' -- ' + PGKSDK_VERSION)   # Set title of Tkinter window

        if osName == 'Darwin':
            root.configure(background='#E7E7E7')

        screenWidth = root.winfo_screenwidth()
        screenHeight = root.winfo_screenheight()

        if osName == 'Windows':

            key = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, "Control Panel\\Desktop\\WindowMetrics")
            value = _winreg.QueryValueEx(key, "AppliedDPI")[0]

            #print "DPI value: " + str(value)

            if value == 96:
                kGUI.WIN_SCALE = 1.0
            elif value == 120:
                kGUI.WIN_SCALE = 1.25
            elif value == 144:
                kGUI.WIN_SCALE = 1.5
            elif value == 192:
                kGUI.WIN_SCALE = 2.0
            else:
                kGUI.WIN_SCALE = value / 96.0

            #print "DPI scale: " + str(kGUI.WIN_SCALE)


            windowWidth = (650 * kGUI.WIN_SCALE)
            windowHeight = (500 * kGUI.WIN_SCALE)

            # Get x & y location for centering the window
            xLocation = screenWidth / 2 - windowWidth / 2
            yLocation = screenHeight / 2 - windowHeight / 2

            root.geometry('%dx%d+%d+%d' % (windowWidth, windowHeight, xLocation, yLocation))
        elif osName == 'Linux':

            windowWidth = 650
            windowHeight = 500

            # Get x & y location for centering the window
            xLocation = screenWidth / 2 - windowWidth / 2
            yLocation = screenHeight / 2 - windowHeight / 2

            root.geometry('%dx%d+%d+%d' % (windowWidth, windowHeight, xLocation, yLocation))
        else:

            #print "Mac Version"

            macVer = platform.mac_ver()[0]

            #print macVer[:5]

            if macVer[:5] == '10.10':
                windowWidth = 620
                windowHeight = 480
            elif macVer[:5] == '10.11':
                windowWidth = 680
                windowHeight = 480

            # Get x & y location for centering the window
            xLocation = screenWidth / 2 - windowWidth / 2
            yLocation = screenHeight / 2 - windowHeight / 2

            root.geometry('%dx%d+%d+%d' % (windowWidth, windowHeight, xLocation, yLocation))

        root.resizable(width=FALSE, height=FALSE)
        self.root = root

        global SDK_PATH
        if DEBUG: print 'SDK_PATH is ' + SDK_PATH
        if osName != 'Darwin':
            self.settingsPath = './settings.json'
        else:
            ##print os.getcwd()
            self.settingsPath = '/Users/' + getpass.getuser() + '/Documents/KSDK_Project_Generator/settings.json'

        if os.path.exists(self.settingsPath):
            kT.update_json_file(self.settingsPath, "ksdkPath", SDK_PATH)
        else:
            self.create_json_config()

        self.app = PgGui(master=root)

        #first step is to launch the main ui
        self.prepare_main_ui_dict()


    def create_json_config(self):
        settingsData = [{'userName':'b46681', 'ksdkPath':SDK_PATH}]
        try:
            with open(self.settingsPath, "w+") as f:
                json.dump(settingsData, f, sort_keys=True, indent=2)
                f.close()
        except IOError:
            tkMessageBox.showinfo("Error", \
                                  'Check Read/Write permissions.')


    def tearDown(self):
        #need destroy the window, otherwise the next case cannot setUp successfully
        if DEBUG: print 'tearDown, destroy the window successfully'
        try:
            self.root.destroy()
        except TclError:
            sys.exit()


    def prepare_main_ui_dict(self):
        if DEBUG: print 'prepare_main_ui_dict'

        main_widigets = {'ksdk_path'        : self.app.widgetList[1],
                         'project_name'     : self.app.widgetList[4],
                         'choose_board'     : self.app.widgetList[6],
                         'advanced'         : self.app.widgetList[11],
                         'quick_generate'   : self.app.widgetList[10],
                         }
        self.dict_main_widgets = main_widigets


    def prepare_advance_ui_dict(self):
        if DEBUG: print "prepare_advance_ui_dict"

        ad_widgets = {'project_name'        : self.app.widgetList[3],
                      'device_or_board_list': self.app.widgetList[8],
                      'project_type_new'    : self.app.widgetList[5], #0
                      'project_type_clone'  : self.app.widgetList[6], #1
                      'lib_config_platform' : self.app.widgetList[11], #1
                      'lib_config_hal'      : self.app.widgetList[10], #0
                      'lib_rtos_none'       : self.app.widgetList[13], #0
                      'lib_rtos_mqx'        : self.app.widgetList[14], #1
                      'lib_rtos_freertos'   : self.app.widgetList[15], #2
                      'lib_rtos_ucosii'     : self.app.widgetList[16], #3
                      'lib_rtos_ucosiii'    : self.app.widgetList[17], #4
                      'choose_device'       : self.app.widgetList[35], #0
                      'choose_board'        : self.app.widgetList[36], #1
                      'tool_kds'            : self.app.widgetList[19],
                      'tool_iar'            : self.app.widgetList[20],
                      'tool_mdk'            : self.app.widgetList[21],
                      'tool_atl'            : self.app.widgetList[22],
                      #'tool_gcc'            : self.app.widgetList[23], #remove by default
                      'include_bsp'         : self.app.widgetList[25],
                      'parent_folder'       : self.app.widgetList[27],
                      'standalone'          : self.app.widgetList[29],
                      'advance_generate'    : self.app.widgetList[31],
                     }

        self.dict_ad_widgets = ad_widgets


    def test_quick_generate(self):
        global g_failure_count
        failure_count_before_test = g_failure_count

        #get the list boards
        w_choose_board = self.dict_main_widgets['choose_board']
        list_items = w_choose_board.get(0, END)
        if DEBUG: print list_items

        #select and quick generate the boards one by one
        boards_num = len(list_items)
        index = 0
        while (index < boards_num):
            #clear the selection
            if index > 0:
                w_choose_board.selection_clear(index - 1 )

            w_choose_board.selection_set(index)
            self.app.update()

            if w_choose_board.selection_get() in SKIP_LIST:
                self.record_failure('SKIP: ' + w_choose_board.selection_get() + ' may block the whole test!')
                index += 1
                continue

            new_project_name = PROJECT_PRE + w_choose_board.selection_get() + "_quick"
            new_project_name = self.append_prefix(new_project_name)

            print '-quick generate: --board:' + list_items[index] + " --project_name:" + new_project_name

            self.set_project_name(self.dict_main_widgets['project_name'], new_project_name)

            # need update the widget before the invoke
            self.prepare_main_ui_dict()
            self.dict_main_widgets['quick_generate'].invoke()
            self.app.update()

            self.wait_and_destroy_pop_gen()

            if AUTO_VERIFICATION:
                global SDK_PATH

                folder_root = os.path.join(SDK_PATH, os.path.join(get_quick_folder_root(), \
                                    os.path.join(dict_board_folder[list_items[index]], \
                                    os.path.join(TEMP_QUICK_FOLDER, new_project_name))))
                self.verify_quick_projects(list_items[index], folder_root)

            if QUICK_TEST: break    # only test one board in quick test

            index += 1

        failure_count_after_test = g_failure_count
        self.assertEqual(failure_count_before_test, failure_count_after_test, "test_quick_generate")


    def append_prefix(self, project_name):
        new_project_name = project_name

        global sdk_info
        if sdk_info.isNewVersion():
            new_project_name = SDK2x_PRE + project_name
        else:
            new_project_name = SDK1x_PRE + project_name

        return new_project_name


    def set_project_name(self, name_wdiget, new_name):
        name_wdiget.delete(0, END)
        name_wdiget.insert(0, new_name.rstrip())


    def wait_and_destroy_pop_gen(self):
        # Need patch to the ksdkGUI.py
        global g_failure_count

        timeout = 0
        while (None == self.app.pop_gen and timeout < TIME_OUT):
            print 'waiting until pop up gen window... '
            time.sleep(1)
            timeout = timeout + 1

        if DEBUG_SLOW: time.sleep(2)

        if timeout >= TIME_OUT:
            print "Time out in waiting gen window !!!!"
            g_failure_count = g_failure_count + 1

        if self.app.pop_gen != None:
            self.app.pop_gen.destroy()
            self.app.pop_gen = None


    def verify_quick_projects(self, platform_name, project_root):
        if DEBUG: print 'verify_quick_project: ' + platform_name + ', ' + project_root
        global sdk_info
        if sdk_info.isToolchainTypeSupported(ToolchainType.KinetisDesignStudio):
            self.verify_project_kds(platform_name, None, project_root)

        if 'Windows' == platform.system():
            if sdk_info.isToolchainTypeSupported(ToolchainType.IARname):
                self.verify_project_iar(platform_name, None, project_root)
            if sdk_info.isToolchainTypeSupported(ToolchainType.KeilMDK):
                self.verify_project_mdk(platform_name, None, project_root)
            if sdk_info.isToolchainTypeSupported(ToolchainType.AtollicStudio):
                self.verify_project_atl(platform_name, None, project_root)
            if sdk_info.isToolchainTypeSupported(ToolchainType.ARMgcc):
                self.verify_project_armgcc(platform_name, None, project_root)


        if sdk_info.isNewVersion():
            # For SDK 2.0, need check the files exist as following
            self.check_source_files(project_root, True)
            self.check_main_c_code(project_root, True)

    def verify_project_iar(self, name, parent_device, project_root):
        self.verify_project_file("iar", ".+\.ewp$", self.get_cpu_serach_key(name, parent_device), project_root)


    def verify_project_kds(self, name, parent_device, project_root):
        self.verify_project_file("kds", "\.cproject$", self.get_cpu_serach_key(name, parent_device), project_root)


    def verify_project_mdk(self, name, parent_device, project_root):
        self.verify_project_file("mdk", ".+\.uvprojx$", self.get_cpu_serach_key(name, parent_device), project_root)


    def verify_project_atl(self, name, parent_device, project_root):
        self.verify_project_file("atl", "\.cproject$", self.get_cpu_serach_key(name, parent_device), project_root)


    def verify_project_armgcc(self, name, parent_device, project_root):
        self.verify_project_file("armgcc", "CMakeLists.txt$", self.get_cpu_serach_key(name, parent_device), project_root)


    def get_cpu_serach_key(self, key, parent_key):
        if DEBUG: print 'Parent key: ' + parent_key + ', key: ' + key
        search_key = ''
        if parent_key != None: # it's device name, need parent key
            search_key = 'CPU_' + dict_device_cpu[parent_key][key]
        else: # it's board name
            search_key = 'CPU_' + dict_board_cpu[key]

        if DEBUG: print "search key: " + search_key

        return search_key


    def verify_project_file(self, toolchain, file_name_reg, search_key, folder_root):
        folder_root = os.path.join(folder_root, toolchain)
        folder_root = kT.string_replace(folder_root, '\\', '/')

        msg = "Didn't generate " + toolchain + " project folder: " + folder_root
        if os.path.exists(folder_root) != True: self.record_failure(msg)

        if ASSERT:
            self.assertEqual(os.path.exists(folder_root), True, msg)
        else:
            return

        is_found = False
        for item in os.listdir(folder_root):
            if DEBUG: print item
            if re.match(file_name_reg, item):
                is_found = True

                is_match_key = self.verify_file_content(os.path.join(folder_root, item), search_key)

                msg = "Wrong project file generated, the platform name does not match " \
                        + search_key + " in " + os.path.join(folder_root, item)
                if False == is_match_key: self.record_failure(msg)
                if ASSERT: self.assertNotEqual(is_match_key, False, msg)
                break

        msg = "Didn't find the project file in: " + folder_root
        if False == is_found: self.record_failure(msg)
        if ASSERT: self.assertNotEqual(is_found, False, msg)


    def verify_file_content(self, file_path, search_key):
        file_path = kT.string_replace(file_path, '\\', '/')

        if not os.path.exists(file_path): return False

        f = open(file_path)
        if DEBUG: print "file to search content: " + file_path + ", key: " + search_key
        content = f.readlines()
        f.close()

        is_match_key = False
        for line in content:
            #if DEBUG: print line
            if re.search(search_key, line):
                is_match_key = True
                break

        return is_match_key


    def check_source_files(self, root_folder_path, need_main_h):
        self.check_folder_file(need_main_h, 'main.h', root_folder_path)
        self.check_folder_file_exists('main.c', root_folder_path)
        self.check_folder_file_exists('board.c', root_folder_path)
        self.check_folder_file_exists('board.h', root_folder_path)
        self.check_folder_file_exists('pin_mux.c', root_folder_path)
        self.check_folder_file_exists('pin_mux.h', root_folder_path)
        self.check_folder_file_exists('clock_config.c', root_folder_path)
        self.check_folder_file_exists('clock_config.h', root_folder_path)


    def check_main_c_code(self, root_folder_path, is_quick_gen):
        main_c_path = os.path.join(root_folder_path, 'main.c')
        main_h_path = os.path.join(root_folder_path, 'main.h')
        #check #include header files
        if is_quick_gen:
            self.check_header_include_code(main_c_path, 'stdio.h')
            self.check_header_include_code(main_c_path, 'main.h')

            self.check_header_include_code(main_h_path, 'fsl_debug_console.h')
            self.check_header_include_code(main_h_path, 'board.h')
            self.check_header_include_code(main_h_path, 'pin_mux.h')
            self.check_header_include_code(main_h_path, 'clock_config.h')
        else:
            self.check_header_include_code(main_c_path, 'fsl_debug_console.h')
            self.check_header_include_code(main_c_path, 'board.h')
            self.check_header_include_code(main_c_path, 'pin_mux.h')
            self.check_header_include_code(main_c_path, 'clock_config.h')

        #check initial functions
        self.check_main_initial_func_code(main_c_path, 'BOARD_InitPins')
        self.check_main_initial_func_code(main_c_path, 'BOARD_BootClockRUN')
        self.check_main_initial_func_code(main_c_path, 'BOARD_InitDebugConsole')

    def check_header_include_code(self, file_path, header):
        search_key = '#include "'+ header + '"'
        if 'stdio.h' == header:
            search_key = '#include <'+ header + '>'
        is_match = self.verify_file_content(file_path, search_key)

        msg = "#include header file is not correct " + search_key + " in " + file_path
        if False == is_match: self.record_failure(msg)
        if ASSERT: self.assertNotEqual(is_match_key, False, msg)


    def check_main_initial_func_code(self, file_path, func):
        is_match = self.verify_file_content(file_path, func)

        msg = "initial function " + func + " is not present in " + file_path
        if False == is_match: self.record_failure(msg)
        if ASSERT: self.assertNotEqual(is_match_key, False, msg)

    def record_failure(self, msg):
        global g_failure_count
        global g_failure_file

        g_failure_count = g_failure_count + 1
        g_failure_file.write(str(g_failure_count) + ". " + msg + "\n")


    def test_advance_platform_boards_all_toolchains(self):
        global g_failure_count
        failure_count_before_test = g_failure_count

        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()

        self.dict_ad_widgets['project_type_new'].invoke()
        self.dict_ad_widgets['choose_board'].invoke()
        self.dict_ad_widgets['lib_config_platform'].invoke()
        self.app.update()

        self.new_all_toolchains(False, False)

        failure_count_after_test = g_failure_count
        self.assertEqual(failure_count_before_test, failure_count_after_test, \
                        "test_advance_platform_boards_all_toolchains")


    def test_advance_platform_device_all_toolchains(self):
        global g_failure_count
        failure_count_before_test = g_failure_count

        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()

        self.dict_ad_widgets['project_type_new'].invoke()
        self.dict_ad_widgets['choose_device'].invoke()
        self.dict_ad_widgets['lib_config_platform'].invoke()
        self.app.update()

        self.new_all_toolchains(True, False)

        failure_count_after_test = g_failure_count
        self.assertEqual(failure_count_before_test, failure_count_after_test, \
                        "test_advance_platform_device_all_toolchains")

    def test_advance_hal_boards_all_toolchains(self):
        global sdk_info
        if sdk_info.isNewVersion():
            self.skipTest('unsupported')

        global g_failure_count
        failure_count_before_test = g_failure_count

        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()

        self.dict_ad_widgets['project_type_new'].invoke()
        self.dict_ad_widgets['choose_board'].invoke()
        self.dict_ad_widgets['lib_config_hal'].invoke()
        self.app.update()

        self.new_all_toolchains(False, True)

        failure_count_after_test = g_failure_count
        self.assertEqual(failure_count_before_test, failure_count_after_test, \
                        "test_advance_hal_boards_all_toolchains")


    def test_advance_hal_device_all_toolchains(self):
        global sdk_info
        if sdk_info.isNewVersion():
            self.skipTest('unsupported')

        global g_failure_count
        failure_count_before_test = g_failure_count

        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()

        self.dict_ad_widgets['project_type_new'].invoke()
        self.dict_ad_widgets['choose_device'].invoke()
        self.dict_ad_widgets['lib_config_hal'].invoke()
        self.app.update()

        self.new_all_toolchains(True, True)

        failure_count_after_test = g_failure_count
        self.assertEqual(failure_count_before_test, failure_count_after_test, \
            "test_advance_hal_device_all_toolchains")


    def new_all_toolchains(self, is_device_part_number, is_hal_only):
        self.prepare_advance_ui_dict()
        w_device_or_board = self.dict_ad_widgets['device_or_board_list']
        boards_list =  w_device_or_board['values']
        if DEBUG: print boards_list

        global sdk_info
        #select all toolchains and bsp
        if sdk_info.isToolchainTypeSupported(ToolchainType.KinetisDesignStudio):
            self.dict_ad_widgets['tool_kds'].invoke()
        if sdk_info.isToolchainTypeSupported(ToolchainType.IARname):
            self.dict_ad_widgets['tool_iar'].invoke()
        if sdk_info.isToolchainTypeSupported(ToolchainType.KeilMDK):
            self.dict_ad_widgets['tool_mdk'].invoke()
        if sdk_info.isToolchainTypeSupported(ToolchainType.AtollicStudio):
            self.dict_ad_widgets['tool_atl'].invoke()
        #self.dict_ad_widgets['tool_gcc'].invoke()
        self.app.update()

        hal_name_pre = ''
        if is_hal_only:
            hal_name_pre = 'hal_'

        rtos_support_list = self.get_rtos_support_list()

        #loop boards
        board_index = 0
        boards_num = len(boards_list)
        while (board_index < boards_num):
            if DEBUG: print 'board index is : %d', board_index
            w_device_or_board.current(newindex=board_index)

            if w_device_or_board.get() in SKIP_LIST:
                self.record_failure('SKIP: ' + w_device_or_board.get() + ' may block the whole test!')
                board_index += 1
                continue

            #loop standalone
            for include_standalone in range(0, 2):
                standalone_name = self.update_checkbox('standalone', include_standalone, '_st_')

                # need reset the device or board selection after changing the rtos setting
                w_device_or_board.current(newindex=board_index)
                self.app.update()

                #loop rtos
                for os_name in rtos_support_list:
                    self.dict_ad_widgets[os_name].invoke()
                    self.app.update()

                    # need reset the device or board selection after changing the rtos setting
                    w_device_or_board.current(newindex=board_index)
                    self.app.update()

                    #some SoCs don't support RTOS, skip to generate the projects
                    if os_name != 'lib_rtos_none' and w_device_or_board.get() in RTOS_NOT_AVAIBLE_LIST:
                        continue

                    if sdk_info.isNewVersion():
                        bsp_loop_count = 1 # V2 release doesn't support BSP
                    else:
                        if False == is_hal_only and 'lib_rtos_none' == os_name:
                            bsp_loop_count = 2
                        else:
                            bsp_loop_count = 1

                    #loop bsp
                    for include_bsp in range(0, bsp_loop_count):
                        bsp_name = self.update_checkbox('include_bsp', include_bsp, '_bsp_')

                        # mux the project_name
                        project_name = PROJECT_PRE + hal_name_pre
                        if is_device_part_number:
                            # to reduce project name length, there is limitation of KDS path length
                            project_name = project_name + '_' + standalone_name + bsp_name + os_name
                        else:
                            project_name = project_name + w_device_or_board.get() \
                                            + '_' + standalone_name + bsp_name + os_name

                        project_name = self.append_prefix(project_name)

                        if is_device_part_number:
                            device_family = boards_list[board_index]
                            for part_num in dict_device_cpu[device_family]:
                                self.execute_generate_and_verify(part_num, project_name + '_' + part_num, \
                                    is_device_part_number, is_hal_only, include_standalone, \
                                    include_bsp, os_name, part_num, 0, device_family) # index is only 0 for part number
                        else:
                            self.execute_generate_and_verify(None, project_name, is_device_part_number, \
                                is_hal_only, include_standalone, include_bsp, os_name, boards_list[board_index], board_index, None)

                    # RTOS does not support hal lib
                    if is_hal_only or is_device_part_number:
                        break   # break the rtos loop

            if QUICK_TEST: break    # only test one board in quick test

            board_index = board_index + 1

    def execute_generate_and_verify(self, part_num, project_name, is_device_part_number, \
                                    is_hal_only, include_standalone, include_bsp, os_name, verify_name, index, parent_key):
        self.set_project_name(self.dict_ad_widgets['project_name'], project_name)
        print '-advance generate: ---project_name:' + project_name

        # need update the widget before the invoke
        self.prepare_advance_ui_dict()
        self.dict_ad_widgets['advance_generate'].invoke()
        self.app.update()

        if is_device_part_number:
            self.wait_and_start_advance_package_gen(part_num)

        self.wait_and_destroy_pop_gen()

        if AUTO_VERIFICATION:
            self.verify_adv_projects(is_hal_only, include_standalone, include_bsp, os_name, \
                                    verify_name, parent_key, self.get_advance_projects_root_folder(project_name, index, parent_key))

    def get_advance_projects_root_folder(self, project_name, index, parent_key):
        global SDK_PATH

        user_board = self.app.localSDK.brdList[index]
        if parent_key != None: # it's device chip, use manifest first evaluation_board
            global evaluation_board_name
            # fix bug that the key is not found exception
            if dict_board_folder.has_key(evaluation_board_name): user_board = evaluation_board_name

        board_folder_name = dict_board_folder[user_board]

        folder_root = os.path.join(os.path.join(os.path.join(os.path.join(\
                        SDK_PATH, get_quick_folder_root()), board_folder_name), TEMP_QUICK_FOLDER), project_name)

        return kT.string_replace(folder_root, '\\', '/')


    def get_rtos_support_list(self):
        rtos_support_list = ['lib_rtos_none']

        global sdk_info

        if sdk_info.isMQXSupported():
            rtos_support_list.append('lib_rtos_mqx')
        if sdk_info.isFreeRTOSSupported():
            rtos_support_list.append('lib_rtos_freertos')
        if sdk_info.isuCOSIISupported():
            rtos_support_list.append('lib_rtos_ucosii')
        if sdk_info.isuCOSIIISupported():
            rtos_support_list.append('lib_rtos_ucosiii')
        return rtos_support_list


    def update_checkbox(self, checkbox_name, select, intial_name):
        default_name = ''
        if select:
            default_name = intial_name
            if len(self.dict_ad_widgets[checkbox_name].state()) <= 0:
                self.dict_ad_widgets[checkbox_name].invoke()
        else:
            if len(self.dict_ad_widgets[checkbox_name].state()) > 0:
                self.dict_ad_widgets[checkbox_name].invoke()

        self.app.update()

        return default_name


    def wait_and_start_advance_package_gen(self, part_num):
        # Need patch to the ksdkGUI.py
        global g_failure_count

        timeout = 0
        while (None == self.app.pop_package and timeout < TIME_OUT):
            # wait until pop package window is ready
            print 'waiting until pop up package window...'
            time.sleep(1)
            timeout = timeout + 1

        if DEBUG_SLOW: time.sleep(2)

        if timeout >= TIME_OUT:
            print "Time out in waiting package window !!!!"
            g_failure_count = g_failure_count + 1

            if self.app.pop_package != None:
                self.app.pop_package.destroy()
                self.app.pop_package = None
        elif self.app.pop_package != None:
            self.update_package(part_num)

            # it will destroy pop_package window
            self.app.begin_advanced_gen(self.app, self.app.pop_package)
            self.app.update()
            self.app.pop_package = None


    def update_package(self, part_num):
        """ Update project device package
        """

        temp = (self.app.newProj.device[0],\
                self.app.newProj.device[1],\
                part_num,\
                self.app.newProj.device[3],\
                self.app.newProj.device[4])

        del self.app.newProj.device

        self.app.newProj.device = temp

        kT.debug_log(self.app.newProj.device)

        del temp


    def verify_adv_projects(self, is_hal_only, include_standalone, include_bsp, os_name, \
                            board_or_device, parent_key, project_root):
        global sdk_info

        if 'Windows' == platform.system() and sdk_info.isNewVersion() != True:
            if is_hal_only:
                # only iar and keil has lib link
                self.verify_project_file("iar", ".+\.eww$", "ksdk_hal_lib", project_root)
                self.verify_project_file("mdk", ".+\.uvprojx$", "ksdk_hal_lib", project_root)
            else:
                # platform link
                self.verify_project_file("iar", ".+\.eww$", dict_os_lib[os_name], project_root)
                self.verify_project_file("mdk", ".+\.uvprojx$", dict_os_lib[os_name], project_root)

        # check the standalone
        self.verify_standalone(is_hal_only, include_standalone, os_name, project_root)

        if sdk_info.isNewVersion() != True:
            # check the bsp, the RTOS includes the bsp file by default
            if 'lib_rtos_mqx' == os_name or 'lib_rtos_freertos' == os_name \
                or 'lib_rtos_ucosii' == os_name or 'lib_rtos_ucosiii' == os_name or include_bsp:
                self.check_folder_file_exists('board', project_root)
            else:
                self.check_folder_file_not_exists('board', project_root)

        if sdk_info.isToolchainTypeSupported(ToolchainType.KinetisDesignStudio):
            self.verify_project_kds(board_or_device, parent_key, project_root)
        if 'Windows' == platform.system():
            # don't verify armgcc so far, because it does not support
            if sdk_info.isToolchainTypeSupported(ToolchainType.IARname):
                self.verify_project_iar(board_or_device, parent_key, project_root)
            if sdk_info.isToolchainTypeSupported(ToolchainType.KeilMDK):
                self.verify_project_mdk(board_or_device, parent_key, project_root)
            if sdk_info.isToolchainTypeSupported(ToolchainType.AtollicStudio):
                self.verify_project_atl(board_or_device, parent_key, project_root)

        if sdk_info.isNewVersion():
            # For SDK 2.0, need check the files exist as following
            self.check_source_files(project_root, False)
            self.check_main_c_code(project_root, False)


    def check_folder_file_exists(self, folder_file, root_folder_path):
        self.check_folder_file(True, folder_file, root_folder_path)

    def check_folder_file_not_exists(self, folder_file, root_folder_path):
        self.check_folder_file(False, folder_file, root_folder_path)

    def check_folder_file(self, exist, folder_file, root_folder_path):
        if exist:
            msg = folder_file + ' does not include in ' + root_folder_path
        else:
            msg = folder_file + ' should not be included in ' + root_folder_path

        if os.path.exists(os.path.join(root_folder_path, folder_file)) != exist:
            self.record_failure(msg)

        if ASSERT:
            self.assertEqual(os.path.exists(os.path.join(root_folder_path, folder_file)), exist, msg)


    def verify_standalone(self, is_hal_only, include_standalone, os_name, folder_root):
        # check the standalone
        global sdk_info
        if include_standalone:
            # check standalone folders required
            if sdk_info.isNewVersion(): # SDK 2.0
                self.check_folder_file_exists('CMSIS', folder_root)
                self.check_folder_file_exists('devices', folder_root)
                if os_name != 'lib_rtos_none':
                    self.check_folder_file_exists('rtos', folder_root)
                    # disable boards folder checking in RC2
                    #self.check_folder_file_exists('boards', folder_root)
            else:
                self.check_folder_file_exists('platform', folder_root)


            # check lib links, only for SDK 1.3
            if sdk_info.isNewVersion() != True:
                self.check_folder_file_exists('lib', folder_root)

                is_found_lib = False
                for dir_name in os.listdir(os.path.join(folder_root, 'lib')):
                    if is_hal_only:
                        if 'ksdk_hal_lib' == dir_name:
                            is_found_lib = True
                            break
                    else:
                        if dict_os_lib[os_name] == dir_name:
                            is_found_lib = True
                            break
                msg = "correct lib should be included in " + os.path.join(folder_root, 'lib')
                if is_found_lib != True: self.record_failure(msg)
                if ASSERT: self.assertEqual(is_found_lib, True, msg)

        else: # not select standalone option
            if sdk_info.isNewVersion():
                self.check_folder_file_not_exists('CMSIS', folder_root)
                self.check_folder_file_not_exists('devices', folder_root)
                self.check_folder_file_not_exists('rtos', folder_root)
                self.check_folder_file_not_exists('boards', folder_root)
            else:
                self.check_folder_file_not_exists('lib', folder_root)
                self.check_folder_file_not_exists('platform', folder_root)


    def test_advance_singal_toolchain_kds(self):
        global sdk_info
        if sdk_info.isToolchainTypeSupported(ToolchainType.KinetisDesignStudio) != True:
            self.skipTest('unsupported')

        global g_failure_count
        failure_count_before_test = g_failure_count

        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()
        self.new_singal_toolchain('tool_kds')

        failure_count_after_test = g_failure_count
        self.assertEqual(failure_count_before_test, failure_count_after_test, \
                        "test_advance_singal_toolchain_kds")


    def test_advance_singal_toolchain_iar(self):
        global sdk_info
        if sdk_info.isToolchainTypeSupported(ToolchainType.IARname) != True:
            self.skipTest('unsupported')

        global g_failure_count
        failure_count_before_test = g_failure_count

        if 'Windows' == platform.system():
            #launch the advance ui
            self.app.advanced_gui(self.root)
            self.prepare_advance_ui_dict()
            self.new_singal_toolchain('tool_iar')

        failure_count_after_test = g_failure_count
        self.assertEqual(failure_count_before_test, failure_count_after_test, \
                        "test_advance_singal_toolchain_iar")


    def test_advance_singal_toolchain_atl(self):
        global sdk_info
        if sdk_info.isToolchainTypeSupported(ToolchainType.AtollicStudio) != True:
            self.skipTest('unsupported')

        global g_failure_count
        failure_count_before_test = g_failure_count

        if 'Windows' == platform.system():
            #launch the advance ui
            self.app.advanced_gui(self.root)
            self.prepare_advance_ui_dict()
            self.new_singal_toolchain('tool_atl')

        failure_count_after_test = g_failure_count
        self.assertEqual(failure_count_before_test, failure_count_after_test, \
                        "test_advance_singal_toolchain_atl")


    def test_advance_singal_toolchain_mdk(self):
        global sdk_info
        if sdk_info.isToolchainTypeSupported(ToolchainType.KeilMDK) != True:
            self.skipTest('unsupported')

        global g_failure_count
        failure_count_before_test = g_failure_count

        if 'Windows' == platform.system():
            #launch the advance ui
            self.app.advanced_gui(self.root)
            self.prepare_advance_ui_dict()
            self.new_singal_toolchain('tool_mdk')

        failure_count_after_test = g_failure_count
        self.assertEqual(failure_count_before_test, failure_count_after_test, \
                        "test_advance_singal_toolchain_mdk")


    def new_singal_toolchain(self, toolchain):

        # only check one board
        self.dict_ad_widgets['choose_board'].invoke()
        self.dict_ad_widgets[toolchain].invoke()
        self.app.update()

        rtos_support_list = self.get_rtos_support_list()

        #loop standalone
        for include_standalone in range(0, 2):
            standalone_name = self.update_checkbox('standalone', include_standalone, '_st_')

            # loop os
            for os_name in rtos_support_list:
                self.dict_ad_widgets[os_name].invoke()
                self.app.update()

                name = self.dict_ad_widgets['device_or_board_list'].get()
                project_name = PROJECT_PRE  + toolchain + '_' + name + '_' + standalone_name + os_name
                project_name = self.append_prefix(project_name)

                self.set_project_name(self.dict_ad_widgets['project_name'], project_name)

                # need update the widget before the invoke
                self.prepare_advance_ui_dict()
                self.dict_ad_widgets['advance_generate'].invoke()
                self.app.update()

                self.wait_and_destroy_pop_gen()

                if AUTO_VERIFICATION:
                    self.verify_singal_toolchain_projects(include_standalone, os_name, toolchain, \
                                                          name, self.get_advance_projects_root_folder(project_name, 0, None))


    def verify_singal_toolchain_projects(self, include_standalone, os_name, toolchain, name, folder_root):
        self.verify_standalone(False, include_standalone, os_name, folder_root)

        self.check_toolchain('kds', folder_root, toolchain)
        if 'Windows' == platform.system():
            self.check_toolchain('iar', folder_root, toolchain)
            self.check_toolchain('mdk', folder_root, toolchain)
            self.check_toolchain('atl', folder_root, toolchain)

            if 'tool_iar' == toolchain:
                self.verify_project_iar(name, None, folder_root)

            if 'tool_mdk' == toolchain:
                self.verify_project_mdk(name, None, folder_root)

            if 'tool_atl' == toolchain:
                self.verify_project_atl(name, None, folder_root)

        if 'tool_kds' == toolchain:
            self.verify_project_kds(name, None, folder_root)


        if sdk_info.isNewVersion():
            # For SDK 2.0, need check the files exist as following
            self.check_source_files(folder_root, False)
            self.check_main_c_code(folder_root, False)


    def check_toolchain(self, tool_chain_name, folder_root, toolchain):
        exist = (('tool_'+ tool_chain_name) == toolchain)
        if os.path.exists(os.path.join(folder_root, tool_chain_name)) != exist:
            if True == exist:
                self.record_failure('should include ' + tool_chain_name + " in the folder: " + folder_root)
            else:
                self.record_failure('should not include ' + tool_chain_name + " in the folder: " + folder_root)

        if ASSERT: self.assertEqual(os.path.exists(os.path.join(folder_root, tool_chain_name)), exist)


    def test_advance_clone(self):
        global g_failure_count
        failure_count_before_test = g_failure_count

        #launch the advance ui
        self.app.advanced_gui(self.root)
        self.prepare_advance_ui_dict()

        self.dict_ad_widgets['project_type_clone'].invoke()
        self.app.update()

        w_demos = self.app.widgetList[36]
        demo_list = w_demos['values']
        if DEBUG: print demo_list

        #loop boards
        demo_index = 0
        demo_num = len(demo_list)
        while (demo_index < demo_num):
            if DEBUG: print 'demo index is : %d', demo_index
            w_demos.current(newindex=demo_index)
            self.app.update()

            #loop standalone
            # change loop to 1, disable "Generate standalone option" when the project is cloned in RC2
            for include_standalone in range(0, 1):
                self.update_checkbox('standalone', include_standalone, '_st_')
                self.app.update()

                if DEBUG_SLOW: time.sleep(1)

                # need update the widget before the invoke
                self.prepare_advance_ui_dict()
                self.dict_ad_widgets['advance_generate'].invoke()
                self.app.update()

                self.wait_and_destroy_pop_gen()

            if QUICK_TEST: break    # only test one board in quick test

            demo_index += 1

        failure_count_after_test = g_failure_count
        self.assertEqual(failure_count_before_test, failure_count_after_test, "test_quick_generate")


if __name__ == '__main__':
    # add SDK path configuration for SDK 2.0 KEx packages batch invoke
    global SDK_PATH
    # SDK_PATH need adjust according to your PC environment
    SDK_PATH = 'D:\\Release\\SDK2.0_Release1\\RC2\\FRDM-K22F_PKG_sdk_2_0_windows_all'
    #SDK_PATH = '/home/ubuntu09/PartNumber_build_test/KSDK_1.3.0_RC3_Linux'
    arg_list = sys.argv[1:]
    if len(arg_list) > 0: SDK_PATH = arg_list[0]

    # replace the folder path
    SDK_PATH = kT.string_replace(SDK_PATH, '\\', '/')

    global sdk_info
    sdk_info = kSdk.kinetisSDK(SDK_PATH)
    print 'sdk_info.isNewVersion():'
    print sdk_info.isNewVersion()


    base_name = os.path.basename(SDK_PATH)
    global g_failure_file
    g_failure_file = open(base_name+FAILURE_LOG_FILE, 'w')
    g_failure_file.truncate()

    clean_env()
    if AUTO_VERIFICATION: load_manifest()

    # restore the argv, otherwise it will impact the unit test framework
    sys.argv=[sys.argv[0]]
    unittest.main()

    g_failure_file.close
